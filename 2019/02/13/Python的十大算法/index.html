<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Python十大机器学习算法入门 | 【Jackie's Dad】个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python十大机器学习算法入门</h1><a id="logo" href="/.">【Jackie's Dad】个人博客</a><p class="description">记录生命中的点点滴滴</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Python十大机器学习算法入门</h1><div class="post-meta"><a href="/2019/02/13/Python的十大算法/#comments" class="comment-count"></a><p><span class="date">Feb 13, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Schlägt</i></i></span></p></div><div class="post-content"><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>线性回归通常用于根据连续变量估计实际数值（房价、呼叫次数、总销售额等）。我们通过拟合最佳直线来建立自变量和因变量的关系。这条最佳直线叫做回归线，并且用 Y= a *X + b 这条线性等式来表示。</p>
<p>理解线性回归的最好办法是回顾一下童年。假设在不问对方体重的情况下，让一个五年级的孩子按体重从轻到重的顺序对班上的同学排序，你觉得这个孩子会怎么做？他（她）很可能会目测人们的身高和体型，综合这些可见的参数来排列他们。这是现实生活中使用线性回归的例子。实际上，这个孩子发现了身高和体型与体重有一定的关系，这个关系看起来很像上面的等式。</p>
<p>在这个等式中：</p>
<ul>
<li>Y：因变量</li>
<li>a：斜率</li>
<li>x：自变量</li>
<li>b ：截距</li>
</ul>
<p>系数 a 和 b 可以通过最小二乘法获得。</p>
<p>参见下例。我们找出最佳拟合直线 <strong>y=0.2811x+13.9</strong>。已知人的身高，我们可以通过这条等式求出体重。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HrMyG1pakst2LXMjYEazxKmShCmJrMtZvESP6eTYn3y3E2AGLicrxbtQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>线性回归的两种主要类型是一元线性回归和多元线性回归。一元线性回归的特点是只有一个自变量。多元线性回归的特点正如其名，存在多个自变量。找最佳拟合直线的时候，你可以拟合到多项或者曲线回归。这些就被叫做多项或曲线回归。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04H4sPK136N8bNT1BzoqfXibw48hfOIlRfYc8ApoR4OeSkMwZKF9Op3ZOA/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#load Train and Test datasets</span></span><br><span class="line"><span class="comment">#Identify feature and response variable(s) and values must be numeric and numpy arrays</span></span><br><span class="line">x_tran &lt;- input_variables_values_training_datasets</span><br><span class="line">y_tran &lt;- target_variables_values_training_datasets</span><br><span class="line">x_test &lt;- input_variables_values_test_datasets</span><br><span class="line">x &lt;- cbind(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Train the model using the training sets and check score</span></span><br><span class="line">linear &lt;_ lm(y_train ~ ., data = x)</span><br><span class="line">summary(linear)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Predict Output</span></span><br><span class="line">predicted = predict(linear,x_test)</span><br></pre></td></tr></table></figure>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>别被它的名字迷惑了！这是一个分类算法而不是一个回归算法。该算法可根据已知的一系列因变量估计离散数值（比方说二进制数值  0 或 1  ，是或否，真或假）。简单来说，它通过将数据拟合进一个逻辑函数来预估一个事件出现的概率。因此，它也被叫做逻辑回归。因为它预估的是概率，所以它的输出值大小在  0 和 1 之间（正如所预计的一样）。</p>
<p>让我们再次通过一个简单的例子来理解这个算法。</p>
<p>假设你的朋友让你解开一个谜题。这只会有两个结果：你解开了或是你没有解开。想象你要解答很多道题来找出你所擅长的主题。这个研究的结果就会像是这样：假设题目是一道十年级的三角函数题，你有  70%的可能会解开这道题。然而，若题目是个五年级的历史题，你只有30%的可能性回答正确。这就是逻辑回归能提供给你的信息。</p>
<p>从数学上看，在结果中，几率的对数使用的是预测变量的线性组合模型。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HAVfia3fa9KC91f5wNPibpXTQHFpMbY7A1tA2o9LrmUnyZVYrZnia3ab9w/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<p>在上面的式子里，p 是我们感兴趣的特征出现的概率。它选用使观察样本值的可能性最大化的值作为参数，而不是通过计算误差平方和的最小值（就如一般的回归分析用到的一样）。</p>
<p>现在你也许要问了，为什么我们要求出对数呢？简而言之，这种方法是复制一个阶梯函数的最佳方法之一。我本可以更详细地讲述，但那就违背本篇指南的主旨了。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HFYddNnMw099JS63WZxg9icia3Ar5U9FPPBHxJBCLAh6lT5IWgbiaImE4w/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>python代码：</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HEJyQIMadibuYk6ZeNlX1ZmicjQoRWLvzPw6qZM6CDVO4l6JNFnrM2rpA/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h1 id="KNN（K-–-最近邻算法）"><a href="#KNN（K-–-最近邻算法）" class="headerlink" title="KNN（K – 最近邻算法）"></a>KNN（K – 最近邻算法）</h1><p>该算法可用于分类问题和回归问题。然而，在业界内，K – 最近邻算法更常用于分类问题。K – 最近邻算法是一个简单的算法。它储存所有的案例，通过周围k个案例中的大多数情况划分新的案例。根据一个距离函数，新案例会被分配到它的 K 个近邻中最普遍的类别中去。</p>
<p>这些距离函数可以是欧式距离、曼哈顿距离、明式距离或者是汉明距离。前三个距离函数用于连续函数，第四个函数（汉明函数）则被用于分类变量。如果 K=1，新案例就直接被分到离其最近的案例所属的类别中。有时候，使用 KNN 建模时，选择 K 的取值是一个挑战。</p>
<p>更多信息：K – 最近邻算法入门（简化版）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HNsV9BTao0sNDul7Y3BMk1d9q9cvzxCyphou62pjg0ic4B64wD5Laubg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>我们可以很容易地在现实生活中应用到 KNN。如果想要了解一个完全陌生的人，你也许想要去找他的好朋友们或者他的圈子来获得他的信息。</p>
<p>在选择使用 KNN 之前，你需要考虑的事情：</p>
<ul>
<li>KNN 的计算成本很高。</li>
<li>变量应该先标准化（normalized），不然会被更高范围的变量偏倚。</li>
<li>在使用KNN之前，要在野值去除和噪音去除等前期处理多花功夫。</li>
</ul>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04Hhl07udatgOzkLibQ9FgqqlyXaQqf4TzvyIEvyfshJ9zBH7kPUmHv6Ig/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h1 id="SVM-支持向量机-Support-Vector-Machine"><a href="#SVM-支持向量机-Support-Vector-Machine" class="headerlink" title="SVM(支持向量机,Support Vector Machine)"></a>SVM(支持向量机,Support Vector Machine)</h1><p>这是一种分类方法。在这个算法中，我们将每个数据在N维空间中用点标出（N是你所有的特征总数），每个特征的值是一个坐标的值。</p>
<p>举个例子，如果我们只有身高和头发长度两个特征，我们会在二维空间中标出这两个变量，每个点有两个坐标（这些坐标叫做支持向量）。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HbzM0IKlJRtalKRmIVw7TgPQjJSgt4VWH2UM0nFKaHMmyCH8mwZ3A7Q/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>现在，我们会找到将两组不同数据分开的一条直线。两个分组中距离最近的两个点到这条线的距离同时最优化。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HbFvIiaDclc39Y4v8LDicgiaicJM81As9aLREgshttV0ftogNgziaEm9DA1Q/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>上面示例中的黑线将数据分类优化成两个小组，两组中距离最近的点（图中A、B点）到达黑线的距离满足最优条件。这条直线就是我们的分割线。接下来，测试数据落到直线的哪一边，我们就将它分到哪一类去。</p>
<p>更多请见：支持向量机的简化</p>
<p><strong>将这个算法想作是在一个 N 维空间玩 JezzBall。需要对游戏做一些小变动：</strong></p>
<ul>
<li>比起之前只能在水平方向或者竖直方向画直线，现在你可以在任意角度画线或平面。</li>
<li>游戏的目的变成把不同颜色的球分割在不同的空间里。</li>
<li>球的位置不会改变。</li>
</ul>
<p><strong>Python代码</strong></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04H8pJHS2LOZQibBw0rYVwuWBq5AJ3GVCxNYkL5X5dxaaHT8mnicPsogQRw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>在预示变量间相互独立的前提下，根据贝叶斯定理可以得到朴素贝叶斯这个分类方法。用更简单的话来说，一个朴素贝叶斯分类器假设一个分类的特性与该分类的其它特性不相关。举个例子，如果一个水果又圆又红<strong>，</strong>并且直径大约是 3 英寸，那么这个水果可能会是苹果。即便这些特性互相依赖<strong>，</strong>或者依赖于别的特性的存在，朴素贝叶斯分类器还是会假设这些特性分别独立地暗示这个水果是个苹果。</p>
<p>朴素贝叶斯模型易于建造，且对于大型数据集非常有用。虽然简单，但是朴素贝叶斯的表现却超越了非常复杂的分类方法。</p>
<p>贝叶斯定理提供了一种从P(c)、P(x)和P(x|c) 计算后验概率 P(c|x) 的方法。请看以下等式：</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HTSVsmthr9xUIgibxMX4HI3o3IbZRRpbLJ1dno1xgHG3NRQTgIPew6sw/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>在这里，</p>
<ul>
<li><em>P</em>(<em>c|x</em>) 是已知预示变量（属性）的前提下，类（目标）的后验概率</li>
<li><em>P</em>(<em>c</em>) 是类的先验概率</li>
<li><em>P</em>(<em>x|c</em>) 是可能性，即已知类的前提下，预示变量的概率</li>
<li><em>P</em>(<em>x</em>) 是预示变量的先验概率</li>
</ul>
<p><strong>例子：</strong>让我们用一个例子来理解这个概念。在下面，我有一个天气的训练集和对应的目标变量“Play”。现在，我们需要根据天气情况，将会“玩”和“不玩”的参与者进行分类。让我们执行以下步骤。</p>
<p>步骤1：把数据集转换成频率表。</p>
<p>步骤2：利用类似“当Overcast可能性为0.29时，玩耍的可能性为0.64”这样的概率，创造 Likelihood 表格。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HibdlUQTJAqjz26wdv40kygEj0BVLMmWoojaAyofW6DYZTzic6IxlUGiaw/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>步骤3：现在，使用朴素贝叶斯等式来计算每一类的后验概率。后验概率最大的类就是预测的结果。</p>
<p><strong>问题：</strong>如果天气晴朗，参与者就能玩耍。这个陈述正确吗？</p>
<p>我们可以使用讨论过的方法解决这个问题。于是 P（会玩 | 晴朗）= P（晴朗 | 会玩）* P（会玩）/ P （晴朗）</p>
<p>我们有 P （晴朗 |会玩）= 3/9 = 0.33，P（晴朗） = 5/14 = 0.36, P（会玩）= 9/14 = 0.64</p>
<p>现在，P(会玩 | 晴朗）= 0.33 * 0.64 / 0.36 = 0.60，有更大的概率。</p>
<p>朴素贝叶斯使用了一个相似的方法，通过不同属性来预测不同类别的概率。这个算法通常被用于文本分类，以及涉及到多个类的问题。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HC718l4wAplp4ia0123wBrfYI1WWC0iaOGjuWToArUPiaicnia5VXeN8VGBQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>这是我最喜爱也是最频繁使用的算法之一。这个监督式学习算法通常被用于分类问题。令人惊奇的是，它同时适用于分类变量和连续因变量。在这个算法中，我们将总体分成两个或更多的同类群。这是根据最重要的属性或者自变量来分成尽可能不同的组别。想要知道更多，可以阅读：简化决策树。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HFR6NHUc1U3MyLA1oKEWpbb6WMOYjo60xlCPPhyKgWDG6G892gia6APg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>在上图中你可以看到，根据多种属性，人群被分成了不同的四个小组，来判断 “他们会不会去玩”。为了把总体分成不同组别，需要用到许多技术，比如说 Gini、Information Gain、Chi-square、entropy。</p>
<p>理解决策树工作机制的最好方式是玩Jezzball，一个微软的经典游戏（见下图）。这个游戏的最终目的，是在一个可以移动墙壁的房间里，通过造墙来分割出没有小球的、尽量大的空间。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HgS7xmwuv4orafuJavUtwH8wfV9nYhmicKMsoJum8hIJicAJibOWiaDSPeA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>因此，每一次你用墙壁来分隔房间时，都是在尝试着在同<a href="https://www.baidu.com/s?wd=%E4%B8%80%E9%97%B4%E6%88%BF&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">一间房</a>里创建两个不同的总体。相似地，决策树也在把总体尽量分割到不同的组里去。</p>
<p>更多信息请见：决策树算法的简化</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HibtXiagqsuvRvJLt5KMyW3s5hZITeUpZ0m3TO2sS4ibL5OMO5gxoicqbcQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h1 id="K均值算法"><a href="#K均值算法" class="headerlink" title="K均值算法"></a>K均值算法</h1><p>K – 均值算法是一种非监督式学习算法，它能解决聚类问题。使用 K – 均值算法来将一个数据归入一定数量的集群（假设有 k 个集群）的过程是简单的。一个集群内的数据点是均匀齐次的，并且异于别的集群。</p>
<p>还记得从墨水渍里找出形状的活动吗？K – 均值算法在某方面类似于这个活动。观察形状，并延伸想象来找出到底有多少种集群或者总体。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HDt0oSMJaKk5IicT2uRpD6iajcOq8h8Qefw6GQ28Y3qKxzqKpG4PeBkmA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><strong>K – 均值算法怎样形成集群：</strong></p>
<ol>
<li>K – 均值算法给每个集群选择k个点。这些点称作为质心。</li>
<li>每一个数据点与距离最近的质心形成一个集群，也就是 k 个集群。</li>
<li>根据现有的类别成员，找出每个类别的质心。现在我们有了新质心。</li>
<li>当我们有新质心后，重复步骤 2 和步骤 3。找到距离每个数据点最近的质心，并与新的k集群联系起来。重复这个过程，直到数据都收敛了，也就是当质心不再改变。</li>
</ol>
<p><strong>如何决定 K 值：</strong></p>
<p>K – 均值算法涉及到集群，每个集群有自己的质心。一个集群内的质心和各数据点之间距离的平方和形成了这个集群的平方值之和。同时，当所有集群的平方值之和加起来的时候，就组成了集群方案的平方值之和。</p>
<p>我们知道，当集群的数量增加时，K值会持续下降。但是，如果你将结果用图表来表示，你会看到距离的平方总和快速减少。到某个值 k 之后，减少的速度就大大下降了。在此，我们可以找到集群数量的最优值。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HTszOW1FKBMPfCYK5Ic4HTkodYyiciboIyN2sf7M1IpzNCAGg7l1lPmpQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><strong>Python</strong></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HUN96plvpymWyLNAq9xSBHibYzvdJic8CGVtibPrFINsPctqFqbu5z4NuQ/640?wx_fmt=png" alt="img"></p>
<h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>随机森林是表示决策树总体的一个专有名词。在随机森林算法中，我们有一系列的决策树（因此又名“森林”）。为了根据一个新对象的属性将其分类，每一个决策树有一个分类，称之为这个决策树“投票”给该分类。这个森林选择获得<a href="https://www.baidu.com/s?wd=%E6%A3%AE%E6%9E%97%E9%87%8C&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">森林里</a>（在所有树中）获得票数最多的分类。</p>
<p>每棵树是像这样种植养成的：</p>
<ol>
<li>如果训练集的案例数是 N，则从 N 个案例中用重置抽样法随机抽取样本。这个样本将作为“养育”树的训练集。</li>
<li>假如有 M 个输入变量，则定义一个数字 m&lt;&lt;M。m 表示，从 M 中随机选中 m 个变量，这 m 个变量中最好的切分会被用来切分该节点。在种植森林的过程中，m 的值保持不变。</li>
<li>尽可能大地种植每一棵树，全程不剪枝。</li>
</ol>
<p><strong>Python</strong></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HpPdpESFBlHSQaFBroMajgYjJbgmZQ6aAlKsicJBuPa9Riap4vot9AsJg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h1 id="Gradient-Boosting-和-AdaBoost-算法"><a href="#Gradient-Boosting-和-AdaBoost-算法" class="headerlink" title="Gradient Boosting 和 AdaBoost 算法"></a>Gradient Boosting 和 AdaBoost 算法</h1><p>当我们要处理很多数据来做一个有高预测能力的预测时，我们会用到 GBM 和 AdaBoost 这两种 boosting 算法。boosting<br>算法是一种集成学习算法。它结合了建立在多个基础估计值基础上的预测结果，来增进单个估计值的可靠程度。这些 boosting<br>算法通常在数据科学比赛如 Kaggl、AV Hackathon、CrowdAnalytix 中很有效。</p>
<p><strong>Python代码</strong></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04Hk08r1qicINOR5ItmzicHM0qbO10k2ribPNW1WS3ZwQdagNEBicsmGtCo5A/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<p>GradientBoostingClassifier 和随机森林是两种不同的 boosting 树分类器。人们常常问起这两个算法之间的区别。</p>
<h1 id="降维算法"><a href="#降维算法" class="headerlink" title="降维算法"></a>降维算法</h1><p>在过去的 4 到 5 年里，在每一个可能的阶段，信息捕捉都呈指数增长。公司、政府机构、研究组织在应对着新资源以外，还捕捉详尽的信息。</p>
<p>举个例子：电子商务公司更详细地捕捉关于顾客的资料：个人信息、网络浏览记录、他们的喜恶、购买记录、反馈以及别的许多信息，比你身边的杂货店售货员更加关注你。</p>
<p>作为一个数据科学家，我们提供的数据包含许多特点。这听起来给建立一个经得起考研的模型提供了很好材料，但有一个挑战：如何从  1000 或者 2000  里分辨出最重要的变量呢？在这种情况下，降维算法和别的一些算法（比如决策树、随机森林、PCA、因子分析）帮助我们根据相关矩阵，缺失的值的比例和别的要素来找出这些重要变量。</p>
<p><strong>Python代码</strong></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWG9KM6qDVnFowanAiaI2O04HIerFDETfBohibAJ99picA2UiaVaialfQwvmXe1kUbVE4EtjWULGPBkDbicg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/02/13/hello-world/" class="next">博客开篇</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线性回归"><span class="toc-text">线性回归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑回归"><span class="toc-text">逻辑回归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KNN（K-–-最近邻算法）"><span class="toc-text">KNN（K – 最近邻算法）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SVM-支持向量机-Support-Vector-Machine"><span class="toc-text">SVM(支持向量机,Support Vector Machine)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#朴素贝叶斯"><span class="toc-text">朴素贝叶斯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#决策树"><span class="toc-text">决策树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#K均值算法"><span class="toc-text">K均值算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#随机森林"><span class="toc-text">随机森林</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gradient-Boosting-和-AdaBoost-算法"><span class="toc-text">Gradient Boosting 和 AdaBoost 算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#降维算法"><span class="toc-text">降维算法</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/Python的十大算法/">Python十大机器学习算法入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/hello-world/">博客开篇</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wangxf2003.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>